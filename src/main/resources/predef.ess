public let ident = { x -> x }
public let >> = { f g x -> (g (f x)) }
public let flip = { f a b -> (f b a) }

public let range = { n ->
	(unfold { state ->
		(match (eq state n) [
			{ True -> None }
			{ False -> (Pair n (+ n 1)) }
		])
	} 0)
}

public let if = { (Bool cond) (Function then) (Function else) ->
	(match cond [
		{ (True) -> (then) }
		{ (False) -> (else) }
	])
}

public type Option = Some x | None

public namespace List {
    public let fold = { (Function folder) state (List list) ->
    	(match list [
    		{ [] -> state }
    		{ (:: h t) -> (. folder (folder state h) t) }
    	])
    }

    public let reverse = (fold (flip ::) [])

    public let foldr = { (Function folder) state (List list) -> (fold folder state (reverse list)) }

    public let map = { (Function mapper) (List list) ->
    	(foldr { acc x -> (:: (mapper x) acc) } [] list)
    }

    public let foreach = { (Function f) (List list) ->
        (match list [
            { [] -> () }
            { (:: h t) ->
                let _ = (f h)
                (. f t)
            }
        ])
    }

    public let unfold = { (Function unfolder) init ->
    	(reverse
    	    ({ state acc ->
                (match (unfolder state) [
                    { (None) -> acc }
                    { (Some (T2 a b)) -> (. b (:: a acc)) }
                ])
            } init [])
    	)
    }
}

public type Tuple = T2 a b | T3 a b c | T4 a b c d
