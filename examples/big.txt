let sum = (fold 0 +)

# unfold = (b -> (Pair a b) Option) -> b -> a List
let unfold = { unfolder init -> 
	let loop = { state acc ->
		(match (unfolder state) [
			{ None -> acc }
			{ Some (Pair a b) -> (loop b (:: a acc)) }
		])
	}
	(loop init [])
}

let range = { n ->
	(unfold { state ->
		(match (== state n) [
			{ True -> None }
			{ False -> (Pair n (+ n 1)) }
		])
	} 0)
}

let if = { cond then else ->
	(match cond [
		{ True -> (then) }
		{ False -> (else) }
	])
}

# type with a block creates a namespace with the same name
type Seq state headf tailf {
	let Simple = { init succ ->
		let hf = id
		let tf = { s -> (Seq (succ s) hf tf) }
		(Seq init hf tf)
	}

	let head = { (Seq s hf tf) -> (hf s) }
	let tail = { (Seq s hf tf) -> (tf s) }

	let map = { mapper (Seq s hf tf) -> (Seq s (hf >> mapper) tf) }

	let take = { n seq ->
		(unfold { (Pair i s) ->
			(if (== 0 i)
				{ -> (None) }
				{ -> (Some (Pair (Seq.head s) (Pair (- i 1) (Seq.tail s)))) }
			)
		} (Pair n seq))
	}
}

let fib = (Seq.map fst
	(Seq.Simple (Pair 1 1) { (Pair a b) -> (Pair b (+ a b)) })
)

let first10fib = (Seq.take 10 fib)
(println first10fib)
